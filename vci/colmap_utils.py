import argparse
import shutil
import os

from sys_utils import *

def fake_undistorted_data(paths: dict[str, str]) -> None:
	# Sparse data
	for f in os.listdir(paths['sparse']):
		shutil.copy(os.path.join(paths['sparse'], f), os.path.join(paths['dense'], "sparse", f))

	# Images
	for f in os.listdir(paths['input']):
		shutil.copy(os.path.join(paths['input'], f), os.path.join(paths['dense'], "images", f))


def run_colmap_poses(paths: dict[str, str], args: argparse.Namespace) -> None:
	"""
	Executes the COLMAP command, producing a sparse or dense reconstruction of the
	input images.
	
	Params:
		paths (dict[str, str]):    A dictionary containg the filepaths
		args (argparse.Namespace): The command line arguments generated by argparse

	Returns:
		None
	"""

	# Create necessary directories
	create_dir(paths['sparse'])
	create_dir(paths['dense'])
	
	# Colmap commands
	print("Starting COLMAP...")
	print()

	sparse_reconstruction_poses(paths, args)

	if not args.skip_dense:
		dense_reconstruction(paths, args)

	if args.gaussian_splatting:
		copy_sparse(paths)

	print("Done.")

def run_colmap_mapper(paths: dict[str, str], args: argparse.Namespace) -> None:
	# Create necessary directories
	create_dir(paths['sparse'])
	create_dir(paths['dense'])
	
	# Colmap commands
	print("Starting COLMAP...")
	print()

	sparse_reconstruction_mapper(paths, args)

	if not args.skip_dense:
		dense_reconstruction(paths, args)

	if args.gaussian_splatting:
		copy_sparse(paths)

	print("Done.")

def sparse_reconstruction_mapper(paths: dict[str, str], args: argparse.Namespace) -> None:
	print("Starting sparse reconstruction...")
	print()

	feature_extract = f"colmap feature_extractor \
		--database_path {paths['db']} \
		--image_path {paths['input']} \
		--ImageReader.camera_model {args.camera} \
		--ImageReader.single_camera_per_image false \
		--SiftExtraction.estimate_affine_shape=true \
		--SiftExtraction.domain_size_pooling=true \
		--SiftExtraction.use_gpu true"
	if args.remove_background:
		feature_extract += f" --ImageReader.mask_path {paths['masks']}"
	exec_cmd(feature_extract)

	feature_matcher = f"colmap exhaustive_matcher \
		--database_path {paths['db']} \
		--SiftMatching.guided_matching=true"
	exec_cmd(feature_matcher)

	mapper = f"colmap mapper \
		--database_path {paths['db']} \
		--image_path {paths['input']} \
		--output_path {paths['sparse']} \
		--Mapper.ba_global_function_tolerance 0.000001 \
		--Mapper.multiple_models false"
	exec_cmd(mapper)

	image_undistortion = f"colmap image_undistorter \
		--image_path {paths['input']} \
		--input_path {os.path.join(paths['sparse'], '0')} \
		--output_path {paths['dense']} \
		--output_type COLMAP"
	exec_cmd(image_undistortion)

	print("Sparse reconstruction done.")
	print()

def sparse_reconstruction_poses(paths: dict[str, str], args: argparse.Namespace) -> None:
	print("Starting sparse reconstruction...")
	print()

	feature_extract = f"colmap feature_extractor \
		--database_path {paths['db']} \
		--image_path {paths['input']}" # --SiftExtraction.estimate_affine_shape=true  --SiftExtraction.domain_size_pooling=true 
	# Pass masks to colmap so there are no points generated for the background
	if args.remove_background:
		feature_extract += f" --ImageReader.mask_path {paths['masks']}"
	exec_cmd(feature_extract)

	feature_matcher = f"colmap exhaustive_matcher \
		--database_path {paths['db']}" # --SiftMatching.guided_matching=true
	exec_cmd(feature_matcher)

	tri_and_map = f"colmap point_triangulator \
		--database_path {paths['db']} \
		--image_path {paths['input']} \
		--input_path {paths['manual']} \
		--output_path {paths['sparse']} \
		--Mapper.ba_global_function_tolerance=0.000001" # --Mapper.ba_global_function_tolerance=0.000001
	exec_cmd(tri_and_map)

	image_undistortion = f"colmap image_undistorter \
		--image_path {paths['input']} \
		--input_path {paths['sparse']} \
		--output_path {paths['dense']}"
	exec_cmd(image_undistortion)

	print("Sparse reconstruction done.")
	print()

def dense_reconstruction(paths: dict[str, str], args: argparse.Namespace) -> None:
	print("Starting dense reconstruction...")
	print()

	patch_match_stereo = f"colmap patch_match_stereo \
		--workspace_path {paths['dense']} \
		--workspace_format COLMAP \
		--PatchMatchStereo.geom_consistency true"
	exec_cmd(patch_match_stereo)

	stereo_fusion = f"colmap stereo_fusion \
		--workspace_path {paths['dense']} \
		--workspace_format COLMAP \
		--input_type geometric \
		--output_path {paths['output']} \
		--output_type PLY"
	if args.remove_background:
		stereo_fusion += f" --StereoFusion.mask_path {paths['masks']}"
	exec_cmd(stereo_fusion)
	
	print("Dense reconstruction done.")
	print()

def copy_sparse(paths: dict[str, str]) -> None:
	sparse = os.path.join(paths['dense'], "sparse")
	sparse0 = os.path.join(paths['dense'], "sparse", "0")

	files = os.listdir(sparse)
	create_dir(sparse0)

	# Copy each file from the source directory to the destination directory (required by 3DGS)
	for file in files:
		if file == '0':
			continue

		source_file = os.path.join(sparse, file)
		destination_file = os.path.join(sparse0, file)
		shutil.move(source_file, destination_file)